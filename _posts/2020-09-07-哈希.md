---
title: 哈希
tags: C++
---





### 一 unordered_map 比较其他 map

> `map,set,multimap,multiset`

迭代器遍历有序：中序遍历

底层实现：红黑树

时间复杂度：`O(logn)`

> `unordered_map,unordered_set,unordered_multimap,unordered_multisets`

迭代器遍历无序

底层实现：哈希

时间复杂度：`O(1)`

**使用场景**

- 对遍历顺序有要求，使用非 `unordered`系列容器
- 对性能要求更高，使用 `unordered` 系列容器



### 二 解决哈希冲突

> 负载因子：实际存放的元素个数 / 空间大小

#### 哈希函数

- 除留余数法

  `元素/键值 % 空间大小 `

#### 闭散列（开放定址法）

**线性探测** 

插入：

- 通过哈希函数计算哈希位置
- 如果当前位置为空，进行插入操作
- 如果当前位置为存在，则从当前位置开始，向后寻找第一个空的位置进行插入

查找：

- 通过哈希函数计算哈希位置
- 查看当前位置的数据是否和要查找的数据相同，如果相同则结束查找
- 如果不相同，继续向后查找。若在找到前遇到了空位，则结束查找

删除：

- 进行查找操作
- 如果找到要删除的数据，将该位置的状态位标记为删除状态

[闭散列实现](https://github.com/hairrrrr/Cpp-Primer/blob/master/Code/Practise/12_%E5%93%88%E5%B8%8C/01/hashTable.cpp)

**二次探测**

哈希冲突时，每次搜索的距离为上一次的平方

#### 开散列（哈希桶）

> 开散列又称链地址法，开链法

插入：

- 指针数组 + 单链表

增容：

- 遍历指针数组中的非空单链表
- 将每个节点重新挂在新表中
- 用 swap 函数交换旧表和新表

寻找：

-  遍历链表

删除：

- 删除链表的节点

迭代器 `++` 操作：

- `begin()` 第一个非空链表的头节点
- `_next` 非空，走到下一个节点
- `_next` 为空，走到下一个非空链表的头节点

[开散列实现](https://github.com/hairrrrr/Cpp-Primer/tree/master/Code/Practise/12_%E5%93%88%E5%B8%8C/02)

### 三 思考

#### 1. 哈希函数在计算时，key 只能为整形，其他类型的 key 如何解决？

我们可以使用一个函数将其转换为整数，然后再使用哈希函数进行计算。比如 string 类型的 key：

```cpp
struct StrToInt
{
	size_t operator()(const string& str)
	{
		size_t hash = 0;
		for (const auto& ch : str)
		{
			hash = hash * 131 + ch;
		}

		return hash;
	}
};
```

[参考文章](https://www.cnblogs.com/-clq/archive/2012/05/31/2528153.html)





#### 2. 总结

![](https://hairrrrr.github.io/assets/2020-09-07-1.jpg)





### 四 位图

>面试题
>
>给40亿个不重复的无符号整数，没排过序。给一个无符号整数，如何快速判断一个数是否在这40亿个数中。【腾讯】

#### 1. 原理

> 用整数的每一位存储一个数是否存在的信息

- 整数的位置：`n / 32`
- 整数位置中具体的 bit 位置：`n % 32`

获取整数中某一个(x) bit 位的值：

`整数 >> (x - 1) & 1`



#### 2. 总结

- 节省空间：一个字节可以存放 8 个整数的二值信息，不存放数据本身
- 效率高：通过哈希映射获取位置，执行位运算，效率：`O(1)` 
- 位图需要的空间大小和数据的范围有关，和数据本身大小没有关系
- 适合场景：**数据不重复，信息简单**

[代码链接](https://github.com/hairrrrr/Cpp-Primer/tree/master/Code/Practise/12_%E5%93%88%E5%B8%8C/03)

#### 3. 问题

```cpp
bool Test(size_t n)
	{

		int idx = n / 32;

		int bitIdx = n % 32;

		// 下面两种写法都可以
		if ((_bit[idx] & (1 << bitIdx)) == 1) 
		//if( ( (_bit[idx] >> bitIdx) & 1) == 1 )
			return true;
		else
			return false;
	}
```

在实现位图的查找功能时，我认为下面两种写法：

- `( _bit[idx] & (1 << bitIdx) ) == 1`
- `( (_bit[idx] >> bitIdx) & 1) == 1`

表达的含义相同。

事实并非如此，我们使用一个简单的案例来测试：

```cpp
void testBit()
{
	int _bit[3] = { 1, 4, 1 };
	int idx = 1;
	int bitIdx = 2;

	int a = _bit[idx] & (1 << bitIdx); // a == 4
	a = (_bit[idx] >> bitIdx) & 1; // a == 1
}
```

这是因为 `1 << bitIdx` 是将权重为  `2^bitIdx` 与 `_bit[idx]` 进行比较，比较的结果势必为 `2^bitIdx` 次方或者 0

而 `_bit[idx] >> bitIdx` 是将 `_bit[idx]` 权重为 `2^bitIdx`  的比特位挪到 1 的位置再与 1 比较，比较结果只会是 1 或 0 了

所以正确的写法是：

```cpp
	if ((_bit[idx] & (1 << bitIdx))) // 不要写 == 1，因为 & 的结果不一定等于 1
		//if( ( (_bit[idx] >> bitIdx) & 1) == 1 )
```





### 五 布隆过滤器

#### 1. 什么是布隆过滤器

我们在使用新闻客户端看新闻时，它会给我们不停地推荐新的内容，它每次推荐时要去重，去掉那些已经看过的内容。问题来了，新闻客户端推荐系统如何实现推送去重的？ 用服务器记录了用户看过的所有历史记录，当推荐系统推荐新闻时会从每个用户的历史记录里进行筛选，过滤掉那些已经存在的记录。 如何快速查找呢？

1. 用哈希表存储用户记录，缺点：浪费空间

2. 用位图存储用户记录，缺点：不能处理哈希冲突

3. 将哈希与位图结合，即布隆过滤器

![](https://hairrrrr.github.io/assets/2020-09-07-2.png)

布隆过滤器依然存在哈希冲突，可能造成误判：一条第一次出现的记录被视为历史记录

#### 2. 布隆过滤器的优缺点

**优点：**

-  增加和查询元素的时间复杂度为:O(K), (K为哈希函数的个数，一般比较小)，与数据量大小无关
- 在能够承受一定的误判时，布隆过滤器比其他数据结构有这很大的空间优势
- 布隆过滤器不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势

**缺点**

-  **有误判率**，即存在假阳性(False Position)，即不能准确判断元素是否在集合中(补救方法：再建立一个白名单，存储可能会误判的数据) 
-  不能获取元素本身
-  一般情况下不能从布隆过滤器中删除元素



[实现代码](https://github.com/hairrrrr/Cpp-Primer/tree/master/Code/Practise/12_%E5%93%88%E5%B8%8C/03)













