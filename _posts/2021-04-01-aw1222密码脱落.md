---
tags: 区间DP DP 蓝桥杯
---



X星球的考古学家发现了一批古代留下来的密码。

这些密码是由A、B、C、D 四种植物的种子串成的序列。

仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。

由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。

你的任务是：

给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。

#### 输入格式

共一行，包含一个由大写字母 ABCD 构成的字符串，表示现在看到的密码串。

#### 输出格式

输出一个整数，表示至少脱落了多少个种子。

#### 数据范围

输入字符串长度不超过1000

#### 输入样例1：

```
ABCBA
```

#### 输出样例1：

```
0
```

#### 输入样例2：

```
ABDCDCBABC
```

#### 输出样例2：

```
3
```

![](D:\图片\A pic\1200题\38.png)

经过分析 `f(L, R - 1) ` 和 `f(L + 1, R)` 包含了 `f(L + 1, R - 1)` 所以第四个状态方程可以舍去

因为如果 R 或 L 不在区间包含了 R 且 L 不再区间（`||` 包含 `&&`）



```cpp
#include<cstdio>
#include<cstring>

using namespace std;

const int N = 1010;

char s[N];
int f[N][N];

int main(void)
{
    scanf("%s", s);
    
    int n = strlen(s);
    
    // 先循环区间长度。因为在计算 f[l][r] 时，可能需要计算 f[l + 1][r]
    // 此时 f[l + 1] 还没有被计算
    for(int len = 1; len <= n; ++len)
    {
        for(int l = 0; l + len - 1 < n; ++l)
        {
            int r = l + len - 1;
            // 如果区间只有一个字符，是回文串
            if(l == r) f[l][r] = 1;
            else
            {
                if(s[l] == s[r]) f[l][r] = f[l + 1][r - 1] + 2;
                if(f[l + 1][r] > f[l][r]) f[l][r] = f[l + 1][r];
                if(f[l][r - 1] > f[l][r]) f[l][r] = f[l][r - 1];
            }
        }
    }
    
    // 至少脱落多少种子等价于最少加上多少字符会变成回文
    // 等价于除去多少字符会变成回文，等价于求最大回文子序列
    // 最终答案为：原字符串长度 - 最大回文子序列
    printf("%d\n", n - f[0][n - 1]);
    
    return 0;
}
```



