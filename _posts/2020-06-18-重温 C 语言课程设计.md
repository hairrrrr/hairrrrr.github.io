---
title: 重温 C 语言课程设计
tags: C
---



![](https://hairrrrr.github.io/assets/2020-06-19-1.jpg)

昨天有个妹子加我微信，说今天她要答辩，希望我帮她看一下课程设计的代码。

这个妹子很心急，“咣咣咣”把代码的七八个函数给我发了过来（这是一个工人的信息管理系统），然后问我“为什么 delete （删除工人信息）函数按照工人的职工号删除职工信息提示成功，但是 list （显示工人信息）函数还是可以打印出来被删除的工人信息？”。

我看了一会一段一段的代码，告诉她，把整个文件发给我。她说“我整理一下代码，然后给你发”。

期间我审视了一下这个代码：不明确的命名，混乱的缩进，乍一看感觉功能很丰富。我感觉这是她抄来的代码，询问她，她也承认了。然后我告诉她“如果你真的想知道这个问题的答案，你明天答辩完，然后来问我，我给你讲解。”

今天晚上我从 7 点多回到家，一直坐在这里修改这个代码，现在是 23 点 35 分。

仔细看这个代码，和网上直接拷贝下来的无异。里面穿插着提示语“请输入学号”和“按职工号打印”，`struct worker` 被 `typedef` 成了 `STU` 。我感觉我主要花费的时间不是修改语法错误，而是在还原一个被她修改的“牛头不对马嘴”代码。

想到这里，现在其实我很生气。我虽然在网上发文章，但是你是我的产品经理吗？我凭什么给你修改代码呢？

晚上 10 点直接把代码发给我，其中自己删删改改几个变量名，然后问我“ delete ...”,好像代码是你自己写的一样，还要不要点脸啊？（呸

不好意思带给大家负面情绪，现在我们来看一下通过这次修改工人信息管理系统能学到什么。



这是我修改后的 `inquiry_worker` （查询工人信息）函数：

```c
void inquiry_worker()         
{	
	int flg;
	struct_worker worker;
	char tar_name[15];
	FILE* fp;

	system("cls");

	if ((fp = fopen("d:\\file1.txt", "rb")) == NULL)
	{
		printf("error in func: %s line: %d %s: \n", __func__, __LINE__, strerror(errno));
		exit(EXIT_FAILURE);
	}

	printf("\n\t请输入职工的职工号:");
	scanf("%s", tar_name);

	while (fread(&worker, sizeof(struct_worker), 1, fp) != 0)
	{
		if (strcmp(tar_name, worker.name) == 0)
		{
			printf("\n\n\n\t职工号\t姓名\t性别\t职务\t电话\n\n");
			printf("\t%s\t%s\t%s\t%s\t%s\n", worker.jobNo, worker.name, worker.gender,worker.position, worker.tel);
			flg = 1; 
			break;
		}
	}

	if (flg == 0)
		printf("该职工不存在！");

	fclose(fp);
	getchar();

	printf("\n\tpress any key to continue...");
	getchar();
	getchar();
}
```

我将潜在的错误范围缩小，你能发现潜在的错误是什么吗：

```c
while (fread(&worker, sizeof(struct_worker), 1, fp) != 0)
	{
		if (strcmp(tar_name, worker.name) == 0)
		{
			printf("\n\n\n\t职工号\t姓名\t性别\t职务\t电话\n\n");
			printf("\t%s\t%s\t%s\t%s\t%s\n", worker.jobNo, worker.name, worker.gender,worker.position, worker.tel);
			flg = 1; 
			break;
		}
	}
```

其实这里的潜在错误和她犯的错误有相通之处。

这是她给我的时候的 delete 函数：

```c
void del()            /*删除函数，完成将文件中的职工数据删除*/
{int i,j,k=0;long del_jobNo;
STU a[15];
FILE *fp;
system("cls");
   if((fp=fopen("c:\\file1.txt","rb"))==NULL)
     {  printf("error!\n");exit(0); }
printf("\n\n 请输入要删除职工的职工号:\n");
scanf("%ld",&del_jobNo);
while(fread(&a,sizeof(STU),1,fp)!=0)
{ for(i=0;i<n;i++)
if(a[i].jobNo==del_jobNo)
  k=1;
  break;
}
   if(k==0)
      printf("该职工不存在！");
   else
   {for(j=i;j<=n-1;j++)
	 strcpy(a[j].jobNo,a[j+1].jobNo);
     n--;
	 printf("删除成功！");
   }
   fclose(fp);  
   getch();
}
```

都是只创建一个变量 `worker` 来不断的从文件 `fp` 中读取内容。

这样做乍一看感觉很妙，但是它有潜在的危机：

如果一个进程首先不是先调用 `input` （初始化工人信息然后输入到文件）函数，而是直接调用 `inquiry_worker` 函数会发什么？它很可能打开的是上一次程序输入的内容或者其他进程输入的内容。这显然是不合适的。

delete 函数的逻辑是这样的：如果找到了要删除的工号，那么从找到的位置的下一元素（数组）个不断向前覆盖。仔细想一下，这其实并不算删除，只是你能读取到的工人少了一个。那么如果这时候循环调用 `fread`函数，因为文件中还是存在你“删除”的内容，`fread` 还会读取成功。这样，自然还会输出被删除的工人信息（或者最后一个工人信息）。

修改的方式有两个：

- 创建一个数组，一次性用 fread 读完现存工人信息（工人数量用一个全局变量标识）
- 声明一个临时变量指示还有多少工人信息没有读入

我重构后的 `inquiry` 函数就是采用第一种方式，`list_workers` （打印工人信息）的实现采用了第二种方式：

```c
	while (cnt-- && (fread(&worker, sizeof(struct_worker), 1, fp) != 0))
		printf("\t%s  \t%s \t%s \t%s \t%s\n", worker.jobNo, worker.name, worker.gender, worker.position, worker.tel);
```

下面是我重构后的 `delete_worker` 函数：

```c
void delete_worker()            
{
	int i, j, flg = 0;
	struct_worker workers[WORKER_MAX], del_jobNo[15];
	FILE* fp;

	system("cls");

	if ((fp = fopen("d:\\file1.txt", "rb+")) == NULL)
	{
		printf("error in func: %s line: %d %s: \n", __func__, __LINE__, strerror(errno));
		exit(EXIT_FAILURE);
	}

	printf("\n\n 请输入要删除职工的职工号:  ");
	scanf("%s", del_jobNo);
	
	if (fread(workers, sizeof(struct_worker), worker_cnt, fp) != worker_cnt)
	{
		printf("error in func: %s line: %d %s: \n", __func__, __LINE__, strerror(errno));
		exit(EXIT_FAILURE);
	}

	
	for (i = 0; i < worker_cnt; i++)
		if (strcmp(workers[i].jobNo, del_jobNo) == 0)
		{
			flg = 1;
			break;
		}
			

	if (flg == 0)
		printf("该职工不存在！");
	else
	{
		for (j = i; j < worker_cnt - 1; j++) 
		{
			strcpy(workers[j].jobNo, workers[j + 1].jobNo);
			strcpy(workers[j].gender, workers[j + 1].gender);
			strcpy(workers[j].name, workers[j + 1].name);
			strcpy(workers[j].position, workers[j + 1].position);
			strcpy(workers[j].tel, workers[j + 1].tel);
		}
		worker_cnt--;

		fseek(fp, 0L, SEEK_SET);
		fwrite(workers, sizeof(struct_worker), worker_cnt, fp);

		printf("删除成功！");
	}

	fclose(fp);
	getchar();
	getchar();
}
```

对比她写的 `delete` 函数，还有一个重要的错误就是删除后没有将新的工人信息写入文件中。

如果这时候我们直接调用 `fwrite` 函数，其实会有潜在的错误：因为我们读取完文件后，文件指针已经偏移了文件开始的位置，这时候你文件中写入，并不会从头开始写！

读过 《C 陷阱与缺陷》的人应该知道：**文件读操作和写操作之间应该调用 `fseek` 函数** 

因此，我们在 `fread`  和 `fwrite` 之间调用 `fseek` 函数，让文件指针回到文件头。

又因为要向文件中写，所以原来打开文件的方式 `rb` 显然不再合适，那应该用那个访问模式呢？

我们来看一下 cppreference 中对访问模式 mode 的描述：

![](https://hairrrrr.github.io/assets/2020-06-19-1.png)

因为我们首先是要读取文件信息，我们不应该在文件不存在时创建新的文件，所以选择 `rb+`

细心的朋友应该发现了，为什么函数最下面调用了两次 `getchar()` ？

因为我需要在这个函数执行完后停留，让用户按下回车，然后再进入下一次的选择。

那么一次 `getchar` 难道不够吗？

当然，第一个 getchar 接受的是 main 函数中用户输入选择后按下的回车：

```c
switch (choice)
		{
			case 1:	input_workers();    break;		/*调用输入函数*/
			case 2:	list_workers();		break;		/*调用显示函数*/
			case 3:	append_workers();   break;		/*调用追加函数*/
			case 4:	sort_workers();		break;		/*调用排序函数*/
			case 5:	inquiry_worker();	break;		/*调用查询函数*/
			case 6:	delete_worker();	break;		/*调用删除函数*/
			case 0:	exit(0);						/*结束程序的运行*/
		}
	} while (choice != 0);
```



其实这次修改这个代码还是学习到了东西，我觉的这个代码唯一的亮点就是 打印的界面感觉还是蛮好看的

![](https://hairrrrr.github.io/assets/2020-06-19-2.png)

```c
		printf("\n\n\n\n\n\t\t\t\t\t Personnel File Management System\n");	/*显示程序菜单*/
		printf("\n\n\t\t\t\t\t*********************************\n\n");
		printf("\t\t\t\t\t\t1----输入职工信息\n");
		printf("\t\t\t\t\t\t2----显示职工信息\n");
		printf("\t\t\t\t\t\t3----追加职工信息\n");
		printf("\t\t\t\t\t\t4----排序职工信息\n");
		printf("\t\t\t\t\t\t5----查询职工信息\n");
		printf("\t\t\t\t\t\t6----删除职工信息\n");
		printf("\t\t\t\t\t\t0----退出\n");
		printf("\n\t\t\t\t\t*********************************\n");
		printf("\n\t\t\t请选择:");
```

[看详细代码]([https://github.com/hairrrrr/C-CrashCourse/tree/master/Coding/Project/01_%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/01_%E5%B7%A5%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F](https://github.com/hairrrrr/C-CrashCourse/tree/master/Coding/Project/01_信息管理系统/01_工人信息管理系统))


