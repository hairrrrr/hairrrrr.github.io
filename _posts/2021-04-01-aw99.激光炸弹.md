---
tags: 蓝桥杯 前缀和
---





https://www.acwing.com/problem/content/101/

地图上有 N 个目标，用整数 Xi,Yi 表示目标在地图上的位置，每个目标都有一个价值 Wi。

**注意**：不同目标可能在同一位置。

现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。

激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，y轴平行。

求一颗炸弹最多能炸掉地图上总价值为多少的目标。

#### 输入格式

第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。

接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。

#### 输出格式

输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。

#### 数据范围

0≤R≤109
0<N≤10000
0≤Xi,Yi≤5000
0≤Wi≤1000

#### 输入样例：

```
2 1
0 0 1
1 1 1
```

#### 输出样例：

```
1
```

题意解读：

如果爆炸的范围与矩形的行列重合，那么摧毁的目标数是 `(R - 1) * (R - 1)` （红色圈圈起来的部分）

![](D:\图片\A pic\1200题\17.png)

要想获得最大的目标摧毁数（`R * R`）可以这样投放炸弹：

![](D:\图片\A pic\1200题\18.png)

`S(x2, y2) - S(x2, y1 - 1) - S(x1 -  1, y2) + S(x1 - 1, y1 - 1)`

设右下的点为 `(i, j)` 那么左上的点为 `(i - R + 1, j - R + 1)` 带入上式得：

`S(i, j) - S(i, j - R) - S(i - R, j) + S(i - R, j - R)`



```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

const int N = 5010;

int n, m;
// 同时开原数组和前缀和数组会让空间溢出
int s[N][N];

int main(void)
{
    int cnt, r;
    cin >> cnt >> r;
    
    // r 是炸弹的范围，棋盘的最大边长为 5001([0, 5000])
    // 计算矩阵时两个点的坐标为 (i, j) (i - r + 1, j - r + 1)
    r = min(5001, r);
    n = m = r;
    
    while(cnt--)
    {
        int x, y, w;
        cin >> x >> y >> w;
        // 前缀和数组 s 从 1 号下标开始存放元素，需要把原来的 x，y 向后挪动
        ++x, ++y;
        n = max(n, x);
        m = max(m, y);
        // 不同目标可能在同一位置
        s[x][y] += w;
    }
    
    // 计算前缀和数组
    for(int i = 1; i <= n; ++i)
    {
        for(int j = 1; j <= m; ++j)
        {
            //s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + s[i][j]; 简化为：
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
        }
    }
    int ans = 0;
    // 从右下角开始枚举
    for(int i = r; i <= n; ++i)
    {
        for(int j = r; j <= m; ++j)
        {
            // `S(i, j) - S(i, j - R) - S(i - R, j) + S(i - R, j - R)`
            ans = max(ans, s[i][j] - s[i][j - r] - s[i - r][j] + s[i - r][j - r]);
        }
    }
    
    cout << ans << endl;
    
    return 0;    
}
```

